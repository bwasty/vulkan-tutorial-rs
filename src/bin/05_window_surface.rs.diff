--- a/04_logical_device.rs
+++ b/05_window_surface.rs
@@ -3,8 +3,11 @@ extern crate vulkano_win;
 extern crate winit;
 
 use std::sync::Arc;
+use std::collections::HashSet;
 
 use winit::{ WindowBuilder, dpi::LogicalSize, Event, WindowEvent};
+use vulkano_win::VkSurfaceBuild;
+
 use vulkano::instance::{
     Instance,
     InstanceExtensions,
@@ -16,6 +19,9 @@ use vulkano::instance::{
 };
 use vulkano::instance::debug::{DebugCallback, MessageTypes};
 use vulkano::device::{Device, DeviceExtensions, Queue};
+use vulkano::swapchain::{
+    Surface,
+};
 
 const WIDTH: u32 = 800;
 const HEIGHT: u32 = 600;
@@ -31,14 +37,15 @@ const ENABLE_VALIDATION_LAYERS: bool = false;
 
 struct QueueFamilyIndices {
     graphics_family: i32,
+    present_family: i32,
 }
 impl QueueFamilyIndices {
     fn new() -> Self {
-        Self { graphics_family: -1 }
+        Self { graphics_family: -1, present_family: -1 }
     }
 
     fn is_complete(&self) -> bool {
-        self.graphics_family >= 0
+        self.graphics_family >= 0 && self.present_family >= 0
     }
 }
 
@@ -46,10 +53,13 @@ impl QueueFamilyIndices {
 struct HelloTriangleApplication {
     instance: Option<Arc<Instance>>,
     debug_callback: Option<DebugCallback>,
+    surface: Option<Arc<Surface<winit::Window>>>,
+
     physical_device_index: usize, // can't store PhysicalDevice directly (lifetime issues)
     device: Option<Arc<Device>>,
 
     graphics_queue: Option<Arc<Queue>>,
+    present_queue: Option<Arc<Queue>>,
 
     events_loop: Option<winit::EventsLoop>,
 }
@@ -60,24 +70,14 @@ impl HelloTriangleApplication {
     }
 
     pub fn run(&mut self) {
-        self.init_window();
         self.init_vulkan();
         // self.main_loop();
     }
 
-    fn init_window(&mut self) {
-        self.events_loop = Some(winit::EventsLoop::new());
-        // We'll leave this and the main loop commented out until we actually
-        // have something to show on screen.
-        let _window_builder = WindowBuilder::new()
-            .with_title("Vulkan")
-            .with_dimensions(LogicalSize::new(f64::from(WIDTH), f64::from(HEIGHT)));
-            // .build(&self.events_loop.as_ref().unwrap());
-    }
-
     fn init_vulkan(&mut self) {
         self.create_instance();
         self.setup_debug_callback();
+        self.create_surface();
         self.pick_physical_device();
         self.create_logical_device();
     }
@@ -164,6 +164,10 @@ impl HelloTriangleApplication {
                 indices.graphics_family = i as i32;
             }
 
+            if self.surface.as_ref().unwrap().is_supported(queue_family).unwrap() {
+                indices.present_family = i as i32;
+            }
+
             if indices.is_complete() {
                 break;
             }
@@ -175,21 +179,43 @@ impl HelloTriangleApplication {
     fn create_logical_device(&mut self) {
         let instance = self.instance.as_ref().unwrap();
         let physical_device = PhysicalDevice::from_index(instance, self.physical_device_index).unwrap();
+
         let indices = self.find_queue_families(&physical_device);
-        let queue_family = physical_device.queue_families()
-            .nth(indices.graphics_family as usize).unwrap();
+
+        let families = [indices.graphics_family, indices.present_family];
+        use std::iter::FromIterator;
+        let unique_queue_families: HashSet<&i32> = HashSet::from_iter(families.iter());
+
         let queue_priority = 1.0;
+        let queue_families = unique_queue_families.iter().map(|i| {
+            (physical_device.queue_families().nth(**i as usize).unwrap(), queue_priority)
+        });
 
         // NOTE: the tutorial recommends passing the validation layers as well
         // for legacy reasons (if ENABLE_VALIDATION_LAYERS is true). Vulkano handles that
         // for us internally.
 
-        let (device, mut queues) = Device::new(physical_device, &Features::none(), &DeviceExtensions::none(),
-            [(queue_family, queue_priority)].iter().cloned())
+        let (device, mut queues) = Device::new(physical_device, &Features::none(),
+            &DeviceExtensions::none(), queue_families)
             .expect("failed to create logical device!");
 
         self.device = Some(device);
-        self.graphics_queue = queues.next();
+
+        // TODO!: simplify
+        self.graphics_queue = queues
+            .find(|q| q.family().id() == physical_device.queue_families().nth(indices.graphics_family as usize).unwrap().id());
+        self.present_queue = queues
+            .find(|q| q.family().id() == physical_device.queue_families().nth(indices.present_family as usize).unwrap().id());
+    }
+
+    fn create_surface(&mut self) {
+        self.events_loop = Some(winit::EventsLoop::new());
+        self.surface = WindowBuilder::new()
+            .with_title("Vulkan")
+            .with_dimensions(LogicalSize::new(f64::from(WIDTH), f64::from(HEIGHT)))
+            .build_vk_surface(&self.events_loop.as_ref().unwrap(), self.instance().clone())
+            .expect("failed to create window surface!")
+            .into();
     }
 
     #[allow(unused)]
