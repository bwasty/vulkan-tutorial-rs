--- a/25_combined_image_sampler.rs
+++ b/26_depth_buffering.rs
@@ -33,18 +33,20 @@ use vulkano::swapchain::{
     acquire_next_image,
     AcquireError,
 };
-use vulkano::format::Format;
+use vulkano::format::{Format, ClearValue};
 use vulkano::image::{
     ImageUsage,
     swapchain::SwapchainImage,
     ImmutableImage,
-    Dimensions
+    Dimensions,
+    AttachmentImage
 };
 use vulkano::sync::{self, SharingMode, GpuFuture};
 use vulkano::pipeline::{
     GraphicsPipeline,
     GraphicsPipelineAbstract,
     viewport::Viewport,
+    depth_stencil::DepthStencil
 };
 use vulkano::framebuffer::{
     RenderPassAbstract,
@@ -121,12 +123,12 @@ impl QueueFamilyIndices {
 
 #[derive(Copy, Clone)]
 struct Vertex {
-    pos: [f32; 2],
+    pos: [f32; 3],
     color: [f32; 3],
     tex: [f32; 2],
 }
 impl Vertex {
-    fn new(pos: [f32; 2], color: [f32; 3], tex: [f32; 2]) -> Self {
+    fn new(pos: [f32; 3], color: [f32; 3], tex: [f32; 2]) -> Self {
         Self { pos, color, tex }
     }
 }
@@ -140,17 +142,25 @@ struct UniformBufferObject {
     proj: Matrix4<f32>,
 }
 
-fn vertices() -> [Vertex; 4] {
+fn vertices() -> [Vertex; 8] {
     [
-        Vertex::new([-0.5, -0.5], [1.0, 0.0, 0.0], [1.0, 0.0]),
-        Vertex::new([0.5, -0.5], [0.0, 1.0, 0.0], [0.0, 0.0]),
-        Vertex::new([0.5, 0.5], [0.0, 0.0, 1.0], [0.0, 1.0]),
-        Vertex::new([-0.5, 0.5], [1.0, 1.0, 1.0], [1.0, 1.0])
+        Vertex::new([-0.5, -0.5, 0.0], [1.0, 0.0, 0.0], [1.0, 0.0]),
+        Vertex::new([0.5, -0.5, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0]),
+        Vertex::new([0.5, 0.5, 0.0], [0.0, 0.0, 1.0], [0.0, 1.0]),
+        Vertex::new([-0.5, 0.5, 0.0], [1.0, 1.0, 1.0], [1.0, 1.0]),
+
+        Vertex::new([-0.5, -0.5, -0.5], [1.0, 0.0, 0.0], [1.0, 0.0]),
+        Vertex::new([0.5, -0.5, -0.5], [0.0, 1.0, 0.0], [0.0, 0.0]),
+        Vertex::new([0.5, 0.5, -0.5], [0.0, 0.0, 1.0], [0.0, 1.0]),
+        Vertex::new([-0.5, 0.5, -0.5], [1.0, 1.0, 1.0], [1.0, 1.0])
     ]
 }
 
-fn indices() -> [u16; 6] {
-    [0, 1, 2, 2, 3, 0]
+fn indices() -> [u16; 12] {
+    [
+        0, 1, 2, 2, 3, 0,
+        4, 5, 6, 6, 7, 4
+    ]
 }
 
 type DescriptorSetUBO = PersistentDescriptorSetBuf<Arc<CpuAccessibleBuffer<UniformBufferObject>>>;
@@ -187,6 +197,8 @@ struct HelloTriangleApplication {
 
     command_buffers: Vec<Arc<AutoCommandBuffer>>,
 
+    depth_format: Format,
+
     previous_frame_end: Option<Box<GpuFuture>>,
     recreate_swap_chain: bool,
 
@@ -206,11 +218,14 @@ impl HelloTriangleApplication {
         let (swap_chain, swap_chain_images) = Self::create_swap_chain(&instance, &surface, physical_device_index,
             &device, &graphics_queue, &present_queue, None);
 
-        let render_pass = Self::create_render_pass(&device, swap_chain.format());
+        let depth_format = Self::find_depth_format();
+        let depth_image = Self::create_depth_image(&device, swap_chain.dimensions(), depth_format);
+
+        let render_pass = Self::create_render_pass(&device, swap_chain.format(), depth_format);
 
         let graphics_pipeline = Self::create_graphics_pipeline(&device, swap_chain.dimensions(), &render_pass);
 
-        let swap_chain_framebuffers = Self::create_framebuffers(&swap_chain_images, &render_pass);
+        let swap_chain_framebuffers = Self::create_framebuffers(&swap_chain_images, &render_pass, &depth_image);
 
         let start_time = Instant::now();
 
@@ -255,6 +270,8 @@ impl HelloTriangleApplication {
 
             command_buffers: vec![],
 
+            depth_format,
+
             previous_frame_end,
             recreate_swap_chain: false,
 
@@ -440,7 +457,22 @@ impl HelloTriangleApplication {
         (swap_chain, images)
     }
 
-    fn create_render_pass(device: &Arc<Device>, color_format: Format) -> Arc<RenderPassAbstract + Send + Sync> {
+    fn find_depth_format() -> Format {
+        // this format is guaranteed to be supported by vulkano and as it stands now, I can't figure
+        // how to do the queries performed in the original tutorial in vulkano...
+        Format::D16Unorm
+    }
+
+    fn create_depth_image(device: &Arc<Device>, dimensions: [u32; 2], format: Format) -> Arc<AttachmentImage<Format>> {
+        AttachmentImage::with_usage(
+            device.clone(),
+            dimensions,
+            format,
+            ImageUsage { depth_stencil_attachment: true, ..ImageUsage::none() }
+        ).unwrap()
+    }
+
+    fn create_render_pass(device: &Arc<Device>, color_format: Format, depth_format: Format) -> Arc<RenderPassAbstract + Send + Sync> {
         Arc::new(single_pass_renderpass!(device.clone(),
             attachments: {
                 color: {
@@ -448,11 +480,19 @@ impl HelloTriangleApplication {
                     store: Store,
                     format: color_format,
                     samples: 1,
+                },
+                depth: {
+                    load: Clear,
+                    store: DontCare,
+                    format: depth_format,
+                    samples: 1,
+                    initial_layout: ImageLayout::Undefined,
+                    final_layout: ImageLayout::DepthStencilAttachmentOptimal,
                 }
             },
             pass: {
                 color: [color],
-                depth_stencil: {}
+                depth_stencil: {depth}
             }
         ).unwrap())
     }
@@ -465,14 +505,14 @@ impl HelloTriangleApplication {
         mod vertex_shader {
             vulkano_shaders::shader! {
                ty: "vertex",
-               path: "src/bin/25_shader_texturesampler.vert"
+               path: "src/bin/26_shader_depthbuffering.vert"
             }
         }
 
         mod fragment_shader {
             vulkano_shaders::shader! {
                 ty: "fragment",
-                path: "src/bin/25_shader_texturesampler.frag"
+                path: "src/bin/26_shader_depthbuffering.frag"
             }
         }
 
@@ -503,6 +543,7 @@ impl HelloTriangleApplication {
             .front_face_counter_clockwise()
             // NOTE: no depth_bias here, but on pipeline::raster::Rasterization
             .blend_pass_through() // = default
+            .depth_stencil(DepthStencil::simple_depth_test())
             .render_pass(Subpass::from(render_pass.clone(), 0).unwrap())
             .build(device.clone())
             .unwrap()
@@ -511,12 +552,14 @@ impl HelloTriangleApplication {
 
     fn create_framebuffers(
         swap_chain_images: &[Arc<SwapchainImage<Window>>],
-        render_pass: &Arc<RenderPassAbstract + Send + Sync>
+        render_pass: &Arc<RenderPassAbstract + Send + Sync>,
+        depth_image: &Arc<AttachmentImage<Format>>
     ) -> Vec<Arc<FramebufferAbstract + Send + Sync>> {
         swap_chain_images.iter()
             .map(|image| {
                 let fba: Arc<FramebufferAbstract + Send + Sync> = Arc::new(Framebuffer::start(render_pass.clone())
-                    .add(image.clone()).unwrap()
+                    .add(image.clone()) .unwrap()
+                    .add(depth_image.clone()).unwrap()
                     .build().unwrap());
                 fba
             }
@@ -637,7 +680,7 @@ impl HelloTriangleApplication {
                     .unwrap()
                     .update_buffer(self.uniform_buffers[i].clone(), Self::update_uniform_buffer(self.start_time, dimensions))
                     .unwrap()
-                    .begin_render_pass(framebuffer.clone(), false, vec![[0.0, 0.0, 0.0, 1.0].into()])
+                    .begin_render_pass(framebuffer.clone(), false, vec![[0.0, 0.0, 0.0, 1.0].into(), ClearValue::Depth(1.0)])
                     .unwrap()
                     .draw_indexed(
                         self.graphics_pipeline.clone(),
@@ -808,13 +851,17 @@ impl HelloTriangleApplication {
     fn recreate_swap_chain(&mut self) {
         let (swap_chain, images) = Self::create_swap_chain(&self.instance, &self.surface, self.physical_device_index,
             &self.device, &self.graphics_queue, &self.present_queue, Some(self.swap_chain.clone()));
+
+        let depth_image = Self::create_depth_image(&self.device, swap_chain.dimensions(), self.depth_format);
+
         self.swap_chain = swap_chain;
         self.swap_chain_images = images;
 
-        self.render_pass = Self::create_render_pass(&self.device, self.swap_chain.format());
+        self.render_pass = Self::create_render_pass(&self.device, self.swap_chain.format(), self.depth_format);
         self.graphics_pipeline = Self::create_graphics_pipeline(&self.device, self.swap_chain.dimensions(),
             &self.render_pass);
-        self.swap_chain_framebuffers = Self::create_framebuffers(&self.swap_chain_images, &self.render_pass);
+
+        self.swap_chain_framebuffers = Self::create_framebuffers(&self.swap_chain_images, &self.render_pass, &depth_image);
         self.create_command_buffers();
     }
 }
